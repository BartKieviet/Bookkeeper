// The background code.  This contains app initialisation stuff, including
// migration of storage formats when necessary, and also handles requests sent
// by some content scripts.

var Sector; // from sector.js
var Building; // from building.js

chrome.runtime.onInstalled.addListener( onInstall );
chrome.runtime.onMessage.addListener( onMessage );

// End of script execution, function definitions below.

function onInstall( details ) {
	var v, maj, min, patch;
	if ( details.reason == 'update' ) {
		parseVersion( details.previousVersion );

		if ( maj < 1
		  || (maj === 1 && min < 8)
		  || (maj === 1 && min === 8 && patch < 1) ) {
			// 1.8.1 is the version when we switched from
			// storage.local to storage.sync and 1.9 format.
			//
			// Too bad, mate, your data is too old, we're going to
			// nuke it, sorry :(
			chrome.storage.sync.clear();
		}
		else if ( maj === 1
		       || (maj === 2 && min === 0) ) {
			// 2.1 is the version when we switched to 2.1 format.
			migrateV19Storage();
		}
	}

	function parseVersion( v ) {
		v = v.split( '.' ).map( function(n) { return parseInt(n); });
		while ( v.length < 3 )
			v.push( 0 );
		maj = v[0];
		min = v[1];
		patch = v[2];
	}
}

// Start a migration from storage V1.9 to V2.1.
//
// V1.9 storage format:
//
// The list item keys are `A`, `O`, `P`.
//
// Building keys are `XNNN` where X is `A`, `O`, or `P`, and NNN is the ID
// (e.g. `P142040`).  Each item contains a 14-element array representing:
//
//   0 - time (number, Unix timestamp in seconds)
//   1 - sector_id (number, as per Sector.getId)
//   2 - x (number)
//   3 - y (number)
//   4 - type_id (number, as per Building.getTypeId)
//   5 - level (number, may be -1 if unavailable)
//   6 - owner (string)
//   7-13 - Seven comm dicts for amount, amount_max, amount_min,
//          res_production, res_upkeep, buy_price, sell_price.
//          In that order.
//
// Commodity dictionaries are stored as arrays of numbers: the first being a
// commodity ID; the second, the value for that commodity, and so on.

// V2.1 storage format:
//
// List item keys, and building keys, remain the same as in 1.9.
//
// Building item values are 3 to 10-element arrays, as generated by
// Building.toStorage() (which we use here, because we can).

function migrateV19Storage() {
	var items;

	console.log( "Starting 1.9 migration" );

	chrome.storage.sync.get( null, onData );

	function onData( old ) {
		var key, m, u, loc, a, b;

		// We'll ignore the stored lists and rebuild them, just because
		// it feels like a good time to tidy up, in case these were out
		// of whack for some reason (mine contain some -1's from failed
		// experiments while developing).
		items = { A: [], O: [], P: [] };

		for ( key in old ) {
			m = /^(A|O|P)(\d+)$/.exec( key );
			if ( !m )
				continue;
			u = m[ 1 ];
			loc = parseInt( m[2] );
			a = old[ key ];
			b = migrateV19Building( loc, a );
			if ( b ) {
				items[ u ].push( loc );
				items[ b.storageKey(u) ] = b.toStorage();
			}
		}

		// Nuke the old data -- feel the willies here
		chrome.storage.sync.clear( onOldBusted );
	}

	function onOldBusted() {
		// Store the new shiny.
		chrome.storage.sync.set( items, onV21Stored );
	}

	function onV21Stored() {
		if ( chrome.runtime.lastError ) {
			// Balls. What else to do?  We won't delete local
			// storage, hopefully another update will migrate it.
			console.log(
				'Bookkeeper ERROR migrating V1.9 storage: ' +
					chrome.runtime.lastError.message );
		}
		else
			console.log( 'Migrated to V2.1!' );
	}

	function migrateV19Building( loc, a ) {
		var level, ticksLeft,
		    res_upkeep, res_production, amount_min, amount_max, amount,
		    selling, buying, id;

		level = parseInt( a[5] );
		if ( isNaN(level) || level < 1 )
			level = undefined;

		amount = parseCommodityMap( a[7] )
		amount_max = parseCommodityMap( a[8] );
		amount_min = parseCommodityMap( a[9] );
		res_production = parseCommodityMap( a[10] );
		res_upkeep = parseCommodityMap( a[11] );

		// If we have amount, amount_max, amount_min, res_production,
		// res_upkeep, then we build selling and buying.  Otherwise, we
		// store the building without amounts.
		if ( amount && amount_max && amount_min &&
		     res_production && res_upkeep ) {

			selling = [];
			buying = [];

			// for each commodity in res_production, compute selling
			// as amount - minimum
			for ( id in res_production ) {
				if ( amount[id] !== undefined &&
				     amount_min[id] !== undefined )
					selling.push(
						id, amount[id] -
							amount_min[id] );
			}

			// for each commodity in res_upkeep, compute buying
			// as maximum - amount
			for ( id in res_upkeep ) {
				if ( amount[id] !== undefined &&
				     amount_max[id] !== undefined )
					buying.push(
						id, amount_max[id] -
							amount[id] );
			}

			if ( selling.length === 0 )
				selling = undefined;
			if ( buying.length === 0 )
				buying = undefined;
		}

		// Compute ticksLeft like 1.9 did
		if ( level && res_upkeep && amount )
			ticksLeft = numberOfTicks( level, res_upkeep, amount );

		// Mins are maxes are only needed for own buildings, and we
		// weren't computing those correctly anyway, so don't store
		// them.

		return new Building(
			loc,
			a[1], // sectorId
			a[4], // typeId
			a[0], // time
			a[6], // owner
			level,
			ticksLeft,
			selling,
			buying
		);
	}

	function parseCommodityMap( a ) {
		var r, i, end;

		if ( a.length === 0 )
			return undefined;

		for ( r = {}, i = 0, end = a.length; i < end; i += 2 )
			r[ a[i] ] = parseInt( a[i + 1] );

		return r;

	}

	// lifted from building.js V1.9
	function numberOfTicks( level, res_upkeep, amount ) {
		var lowest, key, base, tickAmount, ticks;

		if ( !(level > 0) )
			return undefined;

		lowest = Infinity;
		for ( key in res_upkeep ) {
			base = res_upkeep[ key ];
			tickAmount =
				Math.round( base * ( 1 + 0.4 * (level - 1) ) );
			ticks = Math.floor( amount[key] / tickAmount );
			if ( ticks < lowest )
				lowest = ticks;
		}

		if ( lowest < Infinity )
			return lowest;

		return undefined;
	}
} // function function migrateV19Storage()


// The function below is called when a content script asks the background page
// to do some work for it.
//
// The idea is: when a content script needs something, it builds an object with
// a property `op`, which contains a string naming one of the "op handlers"
// defined further down.  Other properties are added to that object, as required
// by the particular handler.  The object is then sent as a message with
// `chrome.runtime.sendMessage`, and is received by the handler below, who
// dispatches it to the appropriate handler.
//
// Some handlers do not respond anything to the content script.  These can take
// a single parameter, the message, and should always return false.
//
// Some handlers may need to deliver data back to the content script, and this
// data may not be immediately available.  These should accept three parameters;
// the third will be a callback function; they should return true immediately
// and arrange for the callback to be called when the response can be delivered.
//
// If a handler returns true, MAKE SURE THE CALLBACK IS CALLED EVENTUALLY,
// otherwise the content script may just sit there waiting for a response that
// will never arrive.  And Chrome will leak a connection to the background page
// indefinitely, keeping it from unloading when the extension is idle.  We want
// none of this.

function onMessage( message, sender, sendResponse ) {
	var handler = OpHandlers[ message.op ];
	if ( handler )
		return handler( message, sendResponse, sender );
	return false;
}

// Op handlers below.

var OpHandlers = {};

OpHandlers.showNotification = function( message ) {
	var options;

	options = {
		type: 'basic',
		title: 'Pardus Bookkeeper',
		message: message.text,
		iconUrl: 'icons/48.png'
	};

	chrome.notifications.create( message.id, options );

	return false;
}

OpHandlers.queryTicksLeft = function( message, sendResponse ) {
	var keys;

	keys = message.ids.map( function(id) { return message.ukey + id; } );
	chrome.storage.sync.get( keys, onData );
	return true;

	function onData( data ) {
		var key, building, r, now, ticksNow;

		r = {};
		now = Building.now();
		for ( key in data ) {
			building = Building.createFromStorage( key, data[key] );
			if ( Building.getTypeShortName( building.typeId ) === 'TO' ) //skip TOs
				continue;
			ticksNow = building.ticksNow( now );
			r[ building.loc ] = {
				t: ticksNow,
				f: ticksNow === building.ticksLeft &&
					building.isFullyStocked(),
				p: building.hasProduction(),
				b: building.buying
			}
		}

		sendResponse( r );
	}
}

// This is magic.

OpHandlers.injectMeHard = function( message, sendResponse, sender ) {
	var scripts, stylesheets, tabId, frameId;

	tabId = sender.tab.id;
	frameId = sender.frameId;
	stylesheets = message.stylesheets || [];
	scripts = message.scripts || [];

	injectStylesheet();

	return true;

	function injectStylesheet() {
		var stylesheet;
		if ( stylesheets.length > 0 ) {
			stylesheet = stylesheets.shift();
			chrome.tabs.insertCSS(
				tabId,
				{ file: stylesheet, frameId: frameId },
				injectStylesheet );
		}
		else
			injectScript();
	}

	function injectScript() {
		var script;
		if ( scripts.length > 0 ) {
			script = scripts.shift();
			chrome.tabs.executeScript(
				tabId,
				{ file: script, frameId: frameId },
				injectScript );
		}
		else
			sendResponse();
	}
}


// Instances of Building represent Pardus buildings.
//
// This script is self-contained; it doesn't rely on any other source.

var Building = (function() {

// Lazily initialised by getTypeId and getTypeIdByIcon

var NAME_IDS, ICON_IDS;

// Construct a new Building instance.
//
// Supply as many parameters as you have data for, and/or use undefined for
// missing data.  Note though: the building will not be fully usable (some
// instance methods may fail) until at least properties `loc`, `sectorId`, and
// `typeId`, have been set.
//
// `loc`, `sectorId`, `typeId`, `time`, `level`, and `ticksLeft`, if provided,
// should be integers.
//
// `owner`, if provided, should be a string.
//
// `selling`, `buying`, `minimum`, `maximum`, `upkeep`, and `production`, if
// provided, should be arrays of integer values.
//
// Note that `time` is expected as a Unix timestamp in *seconds*, not
// milliseconds.  You can use Building.seconds to convert the result of
// Date.now().
//
// If the instance is not initialised fully here, supply the missing properties
// later using the set* methods.
//
// `upkeep` and `production` should only be set when they can't be calculated
// from the building's level, or the when level cannot be estimated.  Usually
// these two properties won't be read directly; methods getUpkeep and
// getProduction can be used instead, which will give these values if available,
// or defer to getNormalUpkeep and getNormalProduction if not.

function Building( loc, sectorId, typeId, time, owner, level, ticksLeft,
		   selling, buying, minimum, maximum, upkeep, production, buyAtPrices, sellAtPrices, credits, psb, amount, tag )
{
	this.loc = intPropVal( loc );
	this.sectorId = intPropVal( sectorId );
	this.typeId = intPropVal( typeId );
	this.time = intPropVal( time ) || Building.now();
	this.owner = owner ? String(owner) : undefined;
	this.level = intPropVal( level );
	this.ticksLeft = intPropVal( ticksLeft );
	this.selling = selling || [];
	this.buying = buying || [];
	this.minimum = minimum || [];
	this.maximum = maximum || [];
	this.upkeep = upkeep || [];
	this.production = production || [];
	this.buyAtPrices = buyAtPrices ? buyAtPrices : [];
	this.sellAtPrices = sellAtPrices ? sellAtPrices : [];
	this.credits = credits ? parseInt( credits ) : undefined;
	this.psb = psb ? true : false;
	this.amount = amount || [];
	this.tag = this.typeId ? Building.makeTag( typeId ) : undefined;

	// These three won't be used until they're needed.  But defining them
	// already anyway so V8 can optimise.
	// https://www.html5rocks.com/en/tutorials/speed/v8/#toc-topic-hiddenclasses
	this.cachedUpkeep = undefined;
	this.cachedProduction = undefined;
	this.projection = undefined;
}



// 1. Properties and methods of the Building object.



// All the building types we care about.
//
// Don't change the order of this array; add new types at the bottom.  The index
// of each object in the array is actually a type ID already kept in
// chrome.storage, so changing this would make a mess of current users' data.
//
// `n` is the building name, `s` is the building short name, `i` is the URL of
// the building image without the image pack prefix and the '.png' suffix.  `bu`
// is the base upkeep for buildings of this type, `bp` is the base production.

Building.CATALOGUE = [
	, // unused index 0
	{ n: 'Alliance Command Station', s: 'ACS',
	  i: 'alliance_command_station', bu: {2:6,19:2}, bp: {} },
	{ n: 'Asteroid Mine', s: 'AM', i: 'asteroid_mine',
	  bu: {1:1,2:1,3:1}, bp: {5:9,14:2} },
	{ n: 'Battleweapons Factory', s: 'BWF', i: 'battleweapons_factory',
	  bu: {1:1,2:2,3:1,6:3,7:3,18:4}, bp: {27:2} },
	{ n: 'Brewery', s: 'Br', i: 'brewery',
	  bu: {1:2,2:2,3:2,13:4}, bp: {15:4}, tag: 'drugchain' },
	{ n: 'Chemical Laboratory', s: 'CL', i: 'chemical_laboratory',
	  bu: {1:1,2:3,3:1}, bp: {13:9}, tag: 'support' },
	{ n: 'Clod Generator', s: 'CG', i: 'clod_generator',
	  bu: {2:4,13:4,21:18}, bp: {23:5} },
	{ n: 'Dark Dome', s: 'DD', i: 'dark_dome',
	  bu: {2:1,50:2}, bp: {21:4,203:12} },
	{ n: 'Droid Assembly Complex', s: 'DAC', i: 'droid_assembly_complex',
	  bu: {1:1,2:3,3:1,8:2,19:3}, bp: {20:1} },
	{ n: 'Drug Station', s: 'DS', i: 'drug_station',
	  bu: {1:3,2:1,3:3,17:3,50:3}, bp: {51:1}, tag: 'drugchain' },
	{ n: 'Electronics Facility', s: 'EF', i: 'electronics_facility',
	  bu: {1:1,2:4,3:1,6:3,9:2}, bp: {7:6} },
	{ n: 'Energy Well', s: 'EW', i: 'energy_well',
	  bu: {1:1,3:1}, bp: {2:6} },
	{ n: 'Fuel Collector', s: 'FC', i: 'fuel_collector',
	  bu: {2:4,13:1}, bp: {16:30} },
	{ n: 'Gas Collector', s: 'GC', i: 'gas_collector',
	  bu: {1:2,2:2,3:2}, bp: {12:20} },
	{ n: 'Handweapons Factory', s: 'HWF', i: 'handweapons_factory',
	  bu: {1:1,2:2,3:1,7:3,9:3,18:3}, bp: {10:2} },
	{ n: 'Leech Nursery', s: 'LN', i: 'leech_nursery',
	  bu: {1:2,2:6,3:10,19:6,23:40}, bp: {21:3,22:1} },
	{ n: 'Medical Laboratory', s: 'ML', i: 'medical_laboratory',
	  bu: {1:2,2:2,3:2,12:7}, bp: {11:4}, tag: 'drugchain' },
	{ n: 'Military Outpost', s: 'MO', i: 'military_outpost',
	  bu: {2:5,16:5,19:0}, bp: {} },
	{ n: 'Nebula Plant', s: 'NP', i: 'nebula_plant',
	  bu: {1:2,3:2,17:3}, bp: {2:35,12:4}, tag: 'support' },
	{ n: 'Neural Laboratory', s: 'NL', i: 'neural_laboratory',
	  bu: {1:2,2:2,3:2,4:12,11:2}, bp: {28:16} },
	{ n: 'Optics Research Center', s: 'ORC', i: 'optics_research_center',
	  bu: {1:1,2:3,3:1,14:2}, bp: {18:10} },
	{ n: 'Plastics Facility', s: 'PF', i: 'plastics_facility',
	  bu: {1:2,2:2,3:2,12:3,13:3}, bp: {9:6} },
	{ n: 'Radiation Collector', s: 'RC', i: 'radiation_collector',
	  bu: {1:1,2:3,3:1}, bp: {19:6} },
	{ n: 'Recyclotron', s: 'Rcy', i: 'recyclotron',
	  bu: {2:3,13:1,21:5}, bp: {1:7,3:5}, tag: 'support' },
	{ n: 'Robot Factory', s: 'RF', i: 'robot_factory',
	  bu: {1:2,2:2,3:2,6:1,7:4,18:2}, bp: {8:3} },
	{ n: 'Slave Camp', s: 'SC', i: 'slave_camp',
	  bu: {1:3,2:1,3:3,11:2,15:2}, bp: {50:3}, tag: 'drugchain' },
	{ n: 'Smelting Facility', s: 'Sm', i: 'smelting_facility',
	  bu: {1:2,2:2,3:2,5:4}, bp: {6:6} },
	{ n: 'Space Farm', s: 'SF', i: 'space_farm',
	  bu: {2:4,4:5}, bp: {1:8,3:2,21:1}, tag: 'support' },
	{ n: 'Stim Chip Mill', s: 'SCM', i: 'stim_chip_mill',
	  bu: {1:3,3:3,7:2,17:2,28:44}, bp: {29:2} },
	{ n: 'Faction Starbase', s: 'F', i: 'starbase_f',
	  bu: {1:2.5, 3:1.75}, bp: {2:4, 4:1.25} },
	{ n: 'Player Starbase', s: 'P', i: 'starbase_p',
	  bu: {1:3, 3:2}, bp: {2:5.25,4:1} },
	{ n: 'Class M Planet', s: 'M', i: 'planet_m',
	  bu: {2:7.5}, bp: {1:3.5, 3:4} },
	{ n: 'Class A Planet', s: 'A', i: 'planet_a',
	  bu: {2:12.5}, bp: {1:10, 3:10} },
	{ n: 'Class D Planet', s: 'D', i: 'planet_d',
	  bu: {3:2.5,14:0.5}, bp: {50:0.15} },
	{ n: 'Class I Planet', s: 'I', i: 'planet_i',
	  bu: {2:7.5}, bp: {1:8, 4:0.1} },
	{ n: 'Class G Planet', s: 'G', i: 'planet_g',
	  bu: {1:1.5, 2:7.5}, bp: {4:0.75, 12:5, 13:0.5} },
	{ n: 'Class R Planet', s: 'R', i: 'planet_r',
	  bu: {1:2.5,2:4,3:2}, bp: {4:1,5:1.5,6:0.5,19:0.1} },
	{ n: 'Trading Outpost', s: 'TO', i: 'trade_outpost',
	  bu: {}, bp: {} }
];

// Convenience for the current time in seconds, so K's heart doesn't break that
// hard...

Building.now = function() {
	return Building.seconds( Date.now() );
}

// Convert a time in milliseconds, like Date uses, to seconds, like Building
// wants.

Building.seconds = function( millis ) {
	return Math.floor( millis / 1000 );
}

// Get the type spec object for the given typeId.  Most likely you'll want to
// use the instance's methods instead, getTypeName etc.

Building.getType = function( typeId ) {
	return Building.CATALOGUE[ typeId ];
}

// If you have the name of a building type (e.g. "Medical Laboratory"), this
// gives you the type id for it.  If the name isn't recognisable, returns
// undefined.

Building.getTypeId = function( name ) {
	if ( NAME_IDS === undefined ) {
		NAME_IDS = Building.CATALOGUE.reduce(
			function( name_ids, data, id ) {
				name_ids[ data.n ] = id;
				return name_ids;
			},
			{}
		);
	}

	return NAME_IDS[ name ];
}

// If you have the URL of the building's image, strip the prefix up to the last
// slash, and the '.png' suffix, then call this for the type id.

Building.getTypeIdByIcon = function( icon ) {
	if ( ICON_IDS === undefined ) {
		ICON_IDS = Building.CATALOGUE.reduce(
			function( icon_ids, data, id ) {
				icon_ids[ data.i ] = id;
				return icon_ids;
			},
			{}
		);
	}

	return ICON_IDS[ icon ];
}

// Get the type name from a type id.

Building.getTypeName = function( typeId ) {
	var t = Building.getType( typeId );
	return t !== undefined ? t.n : undefined;
}

// Get the type short name from a type id (e.g. ACS, DAC, etc.).

Building.getTypeShortName = function( typeId ) {
	var t = Building.getType( typeId );
	return t !== undefined ? t.s : undefined;
}

// Get the base upkeep for "normal" buildings of the given type.  Return an
// object where keys are commodity ids encoded as strings, and values are
// integers.

Building.getBaseUpkeep = function( typeId ) {
	var t = Building.getType( typeId );
	return t !== undefined ? t.bu : undefined;
}

// Get the base production for "normal" buildings of the given type.  Return an
// object where keys are commodity ids encoded as strings, and values are
// integers.

Building.getBaseProduction = function( typeId ) {
	var t = Building.getType( typeId );
	return t !== undefined ? t.bp : undefined;
}

// Get an array of commodity ids that buildings of the given type consume.

Building.getUpkeepCommodities = function( typeId ) {
	var t = Building.getType( typeId );
	return t !== undefined ? Object.keys(t.bu).map(toInt) : undefined;
}

// Get an array of commodity ids that buildings of the given type consume.  Note
// that stim chip mills and dark domes (XXX - only those?) can produce things
// not listed by this.

Building.getProductionCommodities = function( typeId ) {
	var t = Building.getType( typeId );
	return t !== undefined ? Object.keys(t.bp).map(toInt) : undefined;
}

// Get the "normal" upkeep of a building of the given type and level, before
// bonuses and penalties that may apply.

Building.getNormalUpkeep = function( typeId, level ) {
	return computeUpPr( Building.getType(typeId), 'bu', level, 0.4 );
}

// Get the "normal" production of a building of the given type and level, before
// bonuses and penalties that may apply.

Building.getNormalProduction = function( typeId, level ) {
	return computeUpPr( Building.getType(typeId), 'bp', level, 0.5 );
}

// Return true if the given commodity id is consumed by buildings of the given
// type.

Building.isUpkeep = function( typeId, commodityId ) {
	var t = Building.getType( typeId );
	return t !== undefined ? t.bu[commodityId] !== undefined : undefined;
}

// Return true if the given commodity id is produced by buildings of the given
// type (with the SCM, DD caveats).

Building.isProduction = function( typeId, commodityId ) {
	var t = Building.getType( typeId );
	return t !== undefined ? t.bp[commodityId] !== undefined : undefined;
}

// Compute the storage key of a building at the given location and universe.

Building.storageKey = function( universeKey, location ) {
	return universeKey + location;
}

// Create a Building instance from data obtained from storage. `key` is the
// storage key used to retrieve the building; `a` is data retrieved from
// storage.
//
// Do not use building data from storage directly; always create an instance
// with this function, manipulate that, and use its toStorage method if you need
// to store it back.  This lets us change the storage format without having to
// modify the app anywhere but here.

Building.createFromStorage = function( key, a ) {
	// V3.1 format is a 3- to 18-element array.
	var loc = parseInt( key.substr(1) );
	return new Building(
		loc,
		v(a[0]), // sectorId
		v(a[1]), // typeId
		v(a[2]), // timeSecs
		v(a[3]), // owner
		v(a[4]), // level
		v(a[5]), // ticksLeft
		unpackArray( a[6] ), // selling
		unpackArray( a[7] ), // buying
		unpackArray( a[8] ), // minimum
		unpackArray( a[9] ), // maximum
		unpackArray( a[10] ), // upkeep
		unpackArray( a[11] ), // production
		unpackArray( a[12] ), // buyAtPrices, 
		unpackArray( a[13] ), // sellAtPrices, 
		v(a[14]), //credits
		v(a[15]), //psb
		unpackArray( a[16] ), // amount
		v(a[17]) // tag
	);

	// Apparently, we get `null` for items where we set as `undefined` when
	// saving.  We want always undefined after load.  This is below is a
	// very deliberate ==, don't change to ===.
	function v( val ) { return val == null ? undefined : val; }
}

// The number of production ticks elapsed from Unix timestamp `time` to `now`.
// Both are given in seconds past the epoch.  If the latter is omitted, it
// defaults to the current time.

Building.ticksPassed = function( time, now ) {
	return unixToTicks( now ) - unixToTicks( time );

	// Building ticks happen every 6 hours, 25 minutes past
	// the hour, starting at 01:25 UTC.
	// Period is 6h (21600 s). Offset is 1h 25m (5100 s)
	//
	// This returns the number of building ticks that have elapsed since the
	// epoch.

	function unixToTicks( sec ) {
		return Math.floor( (sec - 5100) / 21600 );
	}
}

// Removes the building at location `loc` from storage.  `ukey` is the universe
// key (a single uppercase letter: A, O, P).
//
// This is an unusual function that actually updates `chrome.storage.sync`.
// Added because removing a single building is in fact a common operation.

Building.removeStorage = function( loc, ukey, callback ) {
	loc = parseInt( loc );
	if ( isNaN(loc) )
		return;

	chrome.storage.sync.get( ukey, removeBuildingListEntry );

	function removeBuildingListEntry( data ) {
		var list, index;

		list = data[ ukey ];
		index = list.indexOf( loc );
		if ( index === -1 )
			removeBuildingData();
		else {
			list.splice( index, 1 );
			chrome.storage.sync.set( data, removeBuildingData );
		}
	}

	function removeBuildingData() {
		chrome.storage.sync.remove( ukey + loc, callback )
	}
}

Building.makeTag = function( typeId ) {
	// Puts the tag in tag unless there is no tag then it's blank.
	return Building.CATALOGUE[ typeId ].tag
}

// 2.  Methods of Building instances.



// The following methods do the same as the Building ones, only for the
// instance.

Building.prototype.getType = function() {
	return Building.getType( this.typeId );
}

Building.prototype.getTypeName = function() {
	return Building.getTypeName( this.typeId );
}

Building.prototype.getTypeShortName = function() {
	return Building.getTypeShortName( this.typeId );
}

Building.prototype.getBaseUpkeep = function( typeId ) {
	return Building.getBaseUpkeep( this.typeId );
}

Building.prototype.getBaseProduction = function( typeId ) {
	return Building.getBaseProduction( this.typeId );
}

Building.prototype.getUpkeepCommodities = function( typeId ) {
	return Building.getUpkeepCommodities( this.typeId );
}

Building.prototype.getProductionCommodities = function( typeId ) {
	return Building.getProductionCommodities( this.typeId );
}

Building.prototype.getNormalUpkeep = function( typeId ) {
	return Building.getNormalUpkeep( this.typeId, this.level );
}

Building.prototype.getNormalProduction = function( typeId ) {
	return Building.getNormalProduction( this.typeId, this.level );
}

Building.prototype.isUpkeep = function( commodityId ) {
	return Building.isUpkeep( this.typeId, commodityId );
}

Building.prototype.isProduction = function( commodityId ) {
	return Building.isProduction( this.typeId, commodityId );
}

Building.prototype.getBuyAtPrices = function() {
	return this.buyAtPrices;
}

Building.prototype.getSellAtPrices = function() {
	return this.sellAtPrices;
}

Building.prototype.getAmount = function() {
	return this.amount;
}
	

// Return the number of ticks for which this building still has upkeep.  If a
// projection is active, this will return the projected value.

Building.prototype.getTicksLeft = function() {
	if ( this.projection !== undefined )
		return this.projection.ticksLeft;
	return this.ticksLeft;
}

// Return the array of commodities that this building is buying.  If a
// projection is active, this will return the projected values.  Note that, if a
// projection cannot be performed, you'll see NaN values in the array returned.

Building.prototype.getBuying = function() {
	if ( this.projection !== undefined )
		return this.projection.buying;
	return this.buying;
}

// Return the array of commodities that this building is selling.  If a
// projection is active, this will return the projected values.  Note that, if a
// projection cannot be performed, you'll see NaN values in the array returned.

Building.prototype.getSelling = function() {
	if ( this.projection !== undefined )
		return this.projection.selling;
	return this.selling;
}

// Set the Building's projection, so that methods `getTicksLeft`, `getBuying`
// and `getSelling` return values projected at the given time.  If `time` is
// null, reset the projection, so those methods will return last-updated values.

Building.prototype.project = function( time ) {
	var ticksLeft, elapsed, upkeep, production;

	if ( !time ) {
		this.projection = undefined;
		return;
	}

	if ( this.ticksLeft === undefined )
		setProjection.call(
			this, undefined, this.buying, this.selling );
	else {
		if ( this.ticksLeft > 0 ) {
			ticksLeft = this.ticksNow( time );
			elapsed = this.ticksLeft - ticksLeft;
		}
		else {
			ticksLeft = 0;
			elapsed = 0;
		}

		if ( elapsed === 0 )
			// Could handle below but optimise this common case
			setProjection.call(
				this, ticksLeft, this.buying, this.selling );
		else {
			upkeep = this.getUpkeep();
			production = this.getProduction();
			setProjection.call(
				this,
				ticksLeft,
				this.buying.map(projectUpkeep),
				this.selling.map(projectProduction) );
		}
	}

	// Do note: projectUpkeep and projectProduction will return NaN if the
	// id is not in upkeep/production.  This happens when
	// getUpkeep/getProduction return an empty array, which in turn happens
	// when there is no level and no stored production/upkeep.  We don't
	// check for those things here because the NaN is actually kinda useful:
	// it lets us know which commodities are part of the upkeep and
	// production, just can't be projected.

	function projectUpkeep( amt, id ) {
		return amt + elapsed * upkeep[id];
	}

	// XXX - if/when we track building capacity, we can cap this (and could
	// even tell you when the building will dump.
	function projectProduction( amt, id ) {
		return amt + elapsed * production[id];
	}

	function setProjection( ticksLeft, buying, selling ) {
		this.projection = { ticksLeft, buying, selling };
	}
}

Building.prototype.getUpkeep = function() {
	if ( this.cachedUpkeep )
		return this.cachedUpkeep;
	if ( this.upkeep.length > 0 )
		this.cachedUpkeep = this.upkeep;
	else if ( this.level !== undefined )
		this.cachedUpkeep = this.getNormalUpkeep();
	else
		this.cachedUpkeep = [];
	return this.cachedUpkeep;
}

Building.prototype.getProduction = function() {
	if ( this.cachedProduction )
		return this.cachedProduction;
	if ( this.production.length > 0 )
		this.cachedProduction = this.production;
	else if ( this.level !== undefined )
		this.cachedProduction = this.getNormalProduction();
	else
		this.cachedProduction = [];
	return this.cachedProduction;
}

// The following methods set instance properties.  Prefer these to setting the
// properties directly.

Building.prototype.setLocation = function( loc, sectorId ) {
	this.loc = intPropVal( loc );
	this.sectorId = intPropVal( sectorId );
}

Building.prototype.setType = function( typeId ) {
	this.typeId = intPropVal( typeId );
	this.cachedUpkeep = undefined;
	this.cachedProduction = undefined;
}

Building.prototype.setLevel = function( level ) {
	this.level = intPropVal( level );
	this.cachedUpkeep = undefined;
	this.cachedProduction = undefined;
}

Building.prototype.setTime = function( t ) {
	this.time = intPropVal( t ) || Building.now();
}

Building.prototype.setTicksLeft = function( n ) {
	this.ticksLeft = intPropVal( n );
}

Building.prototype.setOwner = function( owner ) {
	if ( owner !== undefined ) {
		owner = String( owner );
		if ( owner.length === 0 )
			owner = undefined;
	}
	this.owner = owner;
}

Building.prototype.setSelling = function( a ) { this.selling = a || []; }
Building.prototype.setBuying = function( a ) { this.buying = a || []; }
Building.prototype.setMinimum = function( a ) { this.minimum = a || []; }
Building.prototype.setMaximum = function( a ) { this.maximum = a || []; }
Building.prototype.setPSB = function( a ) { this.psb = a || false; }
Building.prototype.setCredits = function( a ) { this.credits = a || null; }

Building.prototype.setUpkeep = function( a ) {
	if ( a ) {
		this.cachedUpkeep = a;
		this.upkeep = a;
	}
	else {
		this.cachedUpkeep = undefined;
		this.upkeep = [];
	}
}

Building.prototype.setProduction = function( a ) {
	if ( a ) {
		this.cachedProduction = a;
		this.production = a;
	}
	else {
		this.cachedProduction = undefined;
		this.production = [];
	}
}

// Check if this building stores minimums and maximums.  That is not often the
// case: currently bookie only stores that for your own buildings, when it
// watches you set the limits in the "trade settings" page.

Building.prototype.hasMinMax = function() {
	return this.minimum.length > 0 && this.maximum.length > 0;
}

// Compute how many ticks of upkeep remain at time `now`, which should be after
// the last time the building was updated.  If omitted, it defaults to the
// current time.  `now` is a timestamp in seconds past the epoch.
//
// If remaining ticks were unknown at the time the building was last updated,
// this function will return undefined.

Building.prototype.ticksNow = function( now ) {
	if ( this.ticksLeft === undefined )
		return undefined;

	 return Math.max(
		 0, this.ticksLeft - Building.ticksPassed(this.time, now) );
}

// Compute the storage key that you'd use to store this building in the given
// universe.

Building.prototype.storageKey = function( universeKey ) {
	return universeKey + this.loc;
}

// Create the object that gets sent to storage when we store a Building.  Do not
// store building data directly; always create a Building instance, use this
// function to obtain the data to store, and send that to storage.  This lets us
// change the storage format when needed, without having to modify the app
// anywhere but here.

Building.prototype.toStorage = function() {
	// V3.1 format is a 3 to 18-element array.
	var a = [
		this.sectorId,
		this.typeId,
		this.time,
		this.owner,
		this.level,
		this.ticksLeft,
		packArray( this.selling ),
		packArray( this.buying ),
		packArray( this.minimum ),
		packArray( this.maximum ),
		packArray( this.upkeep ),
		packArray( this.production ),
		packArray( this.buyAtPrices ), 
		packArray( this.sellAtPrices ), 
		this.credits, 
		this.psb,
		packArray( this.amount ),
		this.tag
	];

	// Shave off the last undefined elements of this.  a.length should never
	// go below 3 here, but we'll check just in case because if we're wrong
	// things would get ugly.
	while ( a.length > 3 && a[ a.length - 1 ] === undefined )
		a.length = a.length - 1;

	return a;
}

// Return an array of commodity ids for commodities that appear in either
// this.buying or this.selling, in numeric order.  Note this is not exactly
// equivalent to getUpkeepCommodities + getProductionCommodities, because things
// like stim chip mills and dark domes produce commodities that are not actually
// listed in the type's base figures.

Building.prototype.getCommoditiesInUse = function() {
	var seen = [], r = [];

	if ( this.buying )
		this.buying.forEach( pushc );
	if ( this.selling )
		this.selling.forEach( pushc );
	return r.sort( compare );

	function pushc( v, i ) {
		if ( !seen[ i ] ) {
			seen[ i ] = true;
			r.push( i );
		}
	}
	function compare( a, b ) { return a - b; }
}

// Remove this building from storage.  This updates `chrome.storage.sync`.

Building.prototype.removeStorage = function( ukey, callback ) {
	Building.removeStorage( this.loc, ukey, callback );
}

// Return true if the building was fully stocked at the time it was last
// updated.  This means that it won't buy any of the commodities it consumes.
// However, if we don't see it buying any commodities at all, then we haven't
// actually recorded it's stocks, so we can't know if it's fully stocked.

Building.prototype.isFullyStocked = function() {
	return this.buying.length > 0 &&
		this.getUpkeepCommodities().find(
			function( commId ) { return this[commId] > 0; },
			this.buying
		) === undefined;
}

// Returns true if the building has any production commodities to sell.
Building.prototype.hasProduction = function() {
	let s = this.getSelling()
	let sum = 0;
	for ( var i = 1; i < s.length ; i++ ) {
		if ( Building.isProduction( this.typeId, i.toString() ) )
			sum += s[i];
	}
	return sum > 0;
}

// 3. Private functions.



// We want our integer properties consistently numbers or undefined.

function intPropVal( v ) {
	if ( v !== undefined ) {
		if ( isNaN( v = parseInt(v) ) )
			v = undefined;
	}
	return v;
}

// Convert a sparse array to the form we send to storage.

function packArray( a ) {
	if ( a.length === 0 )
		return undefined;
	return a.reduce(
		function(scm, val, id) {
			scm.push( id, val );
			return scm;
		},
		[]
	);
}

// Convert an array from storage to a sparse array.

function unpackArray( a ) {
	var r, i, end;
	if ( !a )
		return [];
	for ( r = [], i = 0, end = a.length; i < end; i += 2 )
		r[ a[i] ] = a[ i + 1 ];
	return r;
}

// Compute a normal building upkeep/production from base values and level, using
// formulae from http://www.pardus.at/index.php?section=manual_ref020

function computeUpPr( spec, prop, level, factor ) {
	var base, k, r;
	if ( spec === undefined || level === undefined )
		return undefined;
	base = spec[ prop ];
	r = [];
	for ( k in base )
		r[ k ] = Math.round( base[k] * ( 1 + factor * (level - 1) ) );
	return r;
}

function toInt( s ) { return parseInt( s ); }

return Building;

})();

var Sector = (function() {

// The order of this array is important: numeric sector IDs kept in storage
// depend on the index of each entry here, so DO NOT alter the order.  If Pardus
// ever adds more sectors, *append* them to this array then.
//
// `n` is the sector name, `h` is the sector height, `lb` is the sector's
// locbase (the magic number used to compute tile IDs).

var CATALOGUE = [
	, // index 0 is not used
	{ n: "Aandti", h: 13, lb: 78435 },
	{ n: "AB 5-848", h: 14, lb: 375000 },
	{ n: "Abeho", h: 13, lb: 325645 },
	{ n: "Achird", h: 22, lb: 118538 },
	{ n: "Ackandso", h: 20, lb: 24458 },
	{ n: "Ackarack", h: 20, lb: 300000 },
	{ n: "Ackexa", h: 15, lb: 32188 },
	{ n: "Ackwada", h: 15, lb: 101525 },
	{ n: "Adaa", h: 26, lb: 6409 },
	{ n: "Adara", h: 21, lb: 95219 },
	{ n: "Aedce", h: 20, lb: 306687 },
	{ n: "Aeg", h: 13, lb: 24978 },
	{ n: "Alfirk", h: 15, lb: 95534 },
	{ n: "Algol", h: 25, lb: 375252 },
	{ n: "Alioth", h: 15, lb: 32488 },
	{ n: "Alpha Centauri", h: 12, lb: 1 },
	{ n: "AN 2-956", h: 20, lb: 52083 },
	{ n: "An Dzeve", h: 18, lb: 6981 },
	{ n: "Anaam", h: 20, lb: 16466 },
	{ n: "Anayed", h: 16, lb: 300280 },
	{ n: "Andexa", h: 15, lb: 229 },
	{ n: "Andsoled", h: 25, lb: 318960 },
	{ n: "Anphiex", h: 30, lb: 78721 },
	{ n: "Arexack", h: 17, lb: 325970 },
	{ n: "Atlas", h: 15, lb: 79261 },
	{ n: "Aveed", h: 15, lb: 101855 },
	{ n: "Aya", h: 35, lb: 142998 },
	{ n: "Ayargre", h: 18, lb: 16826 },
	{ n: "Ayinti", h: 20, lb: 300520 },
	{ n: "Ayqugre", h: 14, lb: 307027 },
	{ n: "Baar", h: 12, lb: 79576 },
	{ n: "Baham", h: 36, lb: 139288 },
	{ n: "BE 3-702", h: 20, lb: 119022 },
	{ n: "Becanin", h: 14, lb: 52463 },
	{ n: "Becanol", h: 25, lb: 79768 },
	{ n: "Bedaho", h: 18, lb: 32728 },
	{ n: "Beeday", h: 15, lb: 300920 },
	{ n: "Beethti", h: 20, lb: 17150 },
	{ n: "Begreze", h: 14, lb: 17470 },
	{ n: "Belati", h: 16, lb: 301160 },
	{ n: "Bellatrix", h: 18, lb: 119422 },
	{ n: "Besoex", h: 16, lb: 25251 },
	{ n: "Beta Hydri", h: 20, lb: 102110 },
	{ n: "Beta Proxima", h: 19, lb: 529 },
	{ n: "Betelgeuse", h: 22, lb: 33088 },
	{ n: "Betiess", h: 16, lb: 40935 },
	{ n: "Beurso", h: 25, lb: 319410 },
	{ n: "Bewaack", h: 25, lb: 375727 },
	{ n: "BL 3961", h: 10, lb: 890 },
	{ n: "BL 6-511", h: 31, lb: 80268 },
	{ n: "BQ 3-927", h: 15, lb: 41143 },
	{ n: "BU 5-773", h: 8, lb: 326259 },
	{ n: "Cabard", h: 22, lb: 52701 },
	{ n: "Canaab", h: 13, lb: 7539 },
	{ n: "Canexin", h: 25, lb: 17708 },
	{ n: "Canolin", h: 15, lb: 324186 },
	{ n: "Canopus", h: 22, lb: 41368 },
	{ n: "Capella", h: 17, lb: 33792 },
	{ n: "Cassand", h: 19, lb: 25459 },
	{ n: "CC 3-771", h: 10, lb: 301560 },
	{ n: "Ceanze", h: 17, lb: 307251 },
	{ n: "Cebalrai", h: 24, lb: 119872 },
	{ n: "Cebece", h: 18, lb: 140332 },
	{ n: "Cegreeth", h: 22, lb: 376077 },
	{ n: "Ceina", h: 15, lb: 319885 },
	{ n: "Cemiess", h: 15, lb: 52899 },
	{ n: "Cesoho", h: 7, lb: 1090 },
	{ n: "Cor Caroli", h: 42, lb: 140818 },
	{ n: "CP 2-197", h: 13, lb: 102590 },
	{ n: "Daaya", h: 25, lb: 41654 },
	{ n: "Daaze", h: 15, lb: 320125 },
	{ n: "Daceess", h: 8, lb: 1174 },
	{ n: "Dadaex", h: 21, lb: 326459 },
	{ n: "Dainfa", h: 18, lb: 102798 },
	{ n: "Datiack", h: 15, lb: 18333 },
	{ n: "Daured", h: 17, lb: 103122 },
	{ n: "Daurlia", h: 15, lb: 25706 },
	{ n: "Delta Pavonis", h: 27, lb: 25916 },
	{ n: "DH 3-625", h: 13, lb: 110554 },
	{ n: "DI 9-486", h: 16, lb: 103428 },
	{ n: "Diphda", h: 20, lb: 95834 },
	{ n: "DP 2-354", h: 14, lb: 301760 },
	{ n: "Dsiban", h: 17, lb: 120376 },
	{ n: "Dubhe", h: 25, lb: 142498 },
	{ n: "Edbeeth", h: 15, lb: 18618 },
	{ n: "Edeneth", h: 7, lb: 8273 },
	{ n: "Edenve", h: 25, lb: 81012 },
	{ n: "Edethex", h: 25, lb: 103828 },
	{ n: "Edmial", h: 16, lb: 376473 },
	{ n: "Edmize", h: 16, lb: 18888 },
	{ n: "Edqueth", h: 10, lb: 320380 },
	{ n: "Edvea", h: 24, lb: 301984 },
	{ n: "EH 5-382", h: 15, lb: 96234 },
	{ n: "Electra", h: 16, lb: 42304 },
	{ n: "Elnath", h: 25, lb: 376745 },
	{ n: "Enaness", h: 12, lb: 42672 },
	{ n: "Encea", h: 15, lb: 53169 },
	{ n: "Enif", h: 25, lb: 138413 },
	{ n: "Enioar", h: 13, lb: 307506 },
	{ n: "Enwaand", h: 22, lb: 320550 },
	{ n: "Epsilon Eridani", h: 32, lb: 1294 },
	{ n: "Epsilon Indi", h: 13, lb: 34115 },
	{ n: "Ericon", h: 26, lb: 1870 },
	{ n: "Essaa", h: 22, lb: 34375 },
	{ n: "Eta Cassiopeia", h: 35, lb: 26294 },
	{ n: "Etamin", h: 24, lb: 144398 },
	{ n: "Exackcan", h: 13, lb: 26819 },
	{ n: "Exbeur", h: 25, lb: 53379 },
	{ n: "Exinfa", h: 20, lb: 8357 },
	{ n: "Exiool", h: 19, lb: 104453 },
	{ n: "Faarfa", h: 12, lb: 81637 },
	{ n: "Facece", h: 23, lb: 54004 },
	{ n: "Fadaphi", h: 25, lb: 377195 },
	{ n: "Faedho", h: 25, lb: 307779 },
	{ n: "Faexze", h: 16, lb: 2260 },
	{ n: "Famiay", h: 13, lb: 34617 },
	{ n: "Famida", h: 19, lb: 326837 },
	{ n: "Famiso", h: 15, lb: 42924 },
	{ n: "Faphida", h: 14, lb: 19144 },
	{ n: "Fawaol", h: 25, lb: 302752 },
	{ n: "Fomalhaut", h: 20, lb: 27014 },
	{ n: "Fornacis", h: 30, lb: 145142 },
	{ n: "FR 3-328", h: 20, lb: 320990 },
	{ n: "Furud", h: 20, lb: 120665 },
	{ n: "Gienah Cygni", h: 26, lb: 120965 },
	{ n: "Gilo", h: 21, lb: 81805 },
	{ n: "GM 4-572", h: 13, lb: 54372 },
	{ n: "Gomeisa", h: 23, lb: 145892 },
	{ n: "Greandin", h: 23, lb: 27414 },
	{ n: "Grecein", h: 16, lb: 8557 },
	{ n: "Greenso", h: 16, lb: 377820 },
	{ n: "Grefaho", h: 20, lb: 19452 },
	{ n: "Greliai", h: 20, lb: 303252 },
	{ n: "Gresoin", h: 21, lb: 327312 },
	{ n: "Gretiay", h: 20, lb: 104871 },
	{ n: "GT 3-328", h: 16, lb: 327837 },
	{ n: "GV 4-652", h: 12, lb: 34812 },
	{ n: "HC 4-962", h: 13, lb: 34956 },
	{ n: "Heze", h: 40, lb: 146605 },
	{ n: "HO 2-296", h: 11, lb: 48098 },
	{ n: "Hoanda", h: 18, lb: 2628 },
	{ n: "Hobeex", h: 14, lb: 308129 },
	{ n: "Hocancan", h: 19, lb: 43254 },
	{ n: "Homam", h: 22, lb: 121355 },
	{ n: "Hooth", h: 13, lb: 82183 },
	{ n: "Hource", h: 16, lb: 303572 },
	{ n: "HW 3-863", h: 20, lb: 96444 },
	{ n: "Iceo", h: 14, lb: 8765 },
	{ n: "Inena", h: 21, lb: 35112 },
	{ n: "Inioen", h: 14, lb: 308395 },
	{ n: "Iniolol", h: 14, lb: 27736 },
	{ n: "Inliaa", h: 10, lb: 9045 },
	{ n: "Iohofa", h: 16, lb: 328061 },
	{ n: "Ioliaa", h: 16, lb: 105271 },
	{ n: "Ioquex", h: 15, lb: 82508 },
	{ n: "Iowagre", h: 12, lb: 303876 },
	{ n: "Iozeio", h: 13, lb: 48263 },
	{ n: "IP 3-251", h: 9, lb: 7395 },
	{ n: "Izar", h: 18, lb: 121729 },
	{ n: "JG 2-013", h: 8, lb: 308577 },
	{ n: "JO 4-132", h: 20, lb: 378140 },
	{ n: "JS 2-090", h: 10, lb: 35406 },
	{ n: "Keid", h: 20, lb: 122017 },
	{ n: "Keldon", h: 34, lb: 27974 },
	{ n: "Kenlada", h: 20, lb: 7773 },
	{ n: "Kitalpha", h: 16, lb: 96764 },
	{ n: "KU 3-616", h: 8, lb: 28858 },
	{ n: "Laanex", h: 16, lb: 28954 },
	{ n: "Labela", h: 38, lb: 148005 },
	{ n: "Ladaen", h: 23, lb: 321230 },
	{ n: "Laedgre", h: 20, lb: 43577 },
	{ n: "Lagreen", h: 20, lb: 328445 },
	{ n: "Lahola", h: 21, lb: 54567 },
	{ n: "Lalande", h: 10, lb: 2916 },
	{ n: "Lamice", h: 22, lb: 9165 },
	{ n: "Laolla", h: 17, lb: 20240 },
	{ n: "Lasolia", h: 16, lb: 82748 },
	{ n: "Lave", h: 16, lb: 2986 },
	{ n: "Lavebe", h: 8, lb: 328765 },
	{ n: "Lazebe", h: 19, lb: 122417 },
	{ n: "Leesti", h: 16, lb: 308737 },
	{ n: "Let", h: 34, lb: 328949 },
	{ n: "Liaackti", h: 23, lb: 321690 },
	{ n: "Liaface", h: 20, lb: 308977 },
	{ n: "Lianla", h: 20, lb: 9715 },
	{ n: "Liaququ", h: 24, lb: 105559 },
	{ n: "LN 3-141", h: 6, lb: 29194 },
	{ n: "LO 2-014", h: 3, lb: 35536 },
	{ n: "Maia", h: 13, lb: 35566 },
	{ n: "Matar", h: 16, lb: 122949 },
	{ n: "Mebsuta", h: 20, lb: 97036 },
	{ n: "Menkar", h: 34, lb: 149297 },
	{ n: "Menkent", h: 17, lb: 105967 },
	{ n: "Meram", h: 25, lb: 168151 },
	{ n: "Miackio", h: 16, lb: 304092 },
	{ n: "Miarin", h: 20, lb: 3354 },
	{ n: "Miayack", h: 14, lb: 10115 },
	{ n: "Miayda", h: 17, lb: 378540 },
	{ n: "Micanex", h: 20, lb: 35826 },
	{ n: "Mintaka", h: 25, lb: 150215 },
	{ n: "Miola", h: 19, lb: 329697 },
	{ n: "Miphimi", h: 18, lb: 43957 },
	{ n: "Mizar", h: 23, lb: 51715 },
	{ n: "Naos", h: 18, lb: 106307 },
	{ n: "Nari", h: 37, lb: 137155 },
	{ n: "Nashira", h: 21, lb: 123205 },
	{ n: "Nebul", h: 26, lb: 36226 },
	{ n: "Nekkar", h: 24, lb: 123709 },
	{ n: "Nex 0001", h: 25, lb: 83052 },
	{ n: "Nex 0002", h: 25, lb: 44353 },
	{ n: "Nex 0003", h: 20, lb: 55092 },
	{ n: "Nex 0004", h: 25, lb: 97376 },
	{ n: "Nex 0005", h: 25, lb: 324426 },
	{ n: "Nex 0006", h: 25, lb: 378965 },
	{ n: "Nex Kataam", h: 25, lb: 47473 },
	{ n: "Nhandu", h: 40, lb: 160515 },
	{ n: "Nionquat", h: 20, lb: 36538 },
	{ n: "Nunki", h: 27, lb: 167638 },
	{ n: "Nusakan", h: 19, lb: 98001 },
	{ n: "Oauress", h: 16, lb: 322150 },
	{ n: "Olaeth", h: 14, lb: 124045 },
	{ n: "Olaso", h: 20, lb: 330172 },
	{ n: "Olbea", h: 22, lb: 10451 },
	{ n: "Olcanze", h: 20, lb: 44853 },
	{ n: "Oldain", h: 18, lb: 304492 },
	{ n: "Olexti", h: 16, lb: 3494 },
	{ n: "Ollaffa", h: 14, lb: 309377 },
	{ n: "Olphize", h: 21, lb: 20858 },
	{ n: "Omicron Eridani", h: 19, lb: 36838 },
	{ n: "Ook", h: 15, lb: 3622 },
	{ n: "Ophiuchi", h: 20, lb: 55592 },
	{ n: "Orerve", h: 15, lb: 3847 },
	{ n: "Oucanfa", h: 15, lb: 379590 },
	{ n: "PA 2-013", h: 17, lb: 330672 },
	{ n: "Paan", h: 23, lb: 56032 },
	{ n: "Pardus", h: 93, lb: 151215 },
	{ n: "Pass EMP-01", h: 25, lb: 15053 },
	{ n: "Pass EMP-02", h: 20, lb: 15553 },
	{ n: "Pass EMP-03", h: 20, lb: 31688 },
	{ n: "Pass EMP-04", h: 25, lb: 58622 },
	{ n: "Pass EMP-05", h: 20, lb: 59247 },
	{ n: "Pass EMP-06", h: 13, lb: 110762 },
	{ n: "Pass EMP-07", h: 23, lb: 312856 },
	{ n: "Pass EMP-08", h: 21, lb: 313431 },
	{ n: "Pass EMP-09", h: 25, lb: 313956 },
	{ n: "Pass EMP-10", h: 25, lb: 314581 },
	{ n: "Pass EMP-11", h: 22, lb: 315206 },
	{ n: "Pass FED-01", h: 17, lb: 15913 },
	{ n: "Pass FED-02", h: 19, lb: 16219 },
	{ n: "Pass FED-03", h: 15, lb: 39275 },
	{ n: "Pass FED-04", h: 22, lb: 39530 },
	{ n: "Pass FED-05", h: 21, lb: 40080 },
	{ n: "Pass FED-06", h: 23, lb: 40521 },
	{ n: "Pass FED-07", h: 15, lb: 85857 },
	{ n: "Pass FED-08", h: 23, lb: 315536 },
	{ n: "Pass FED-09", h: 17, lb: 315858 },
	{ n: "Pass FED-10", h: 20, lb: 316249 },
	{ n: "Pass FED-11", h: 17, lb: 316629 },
	{ n: "Pass FED-12", h: 22, lb: 317003 },
	{ n: "Pass FED-13", h: 21, lb: 381583 },
	{ n: "Pass UNI-01", h: 16, lb: 111087 },
	{ n: "Pass UNI-02", h: 10, lb: 111487 },
	{ n: "Pass UNI-03", h: 20, lb: 111587 },
	{ n: "Pass UNI-04", h: 25, lb: 127261 },
	{ n: "Pass UNI-05", h: 26, lb: 127886 },
	{ n: "Pass UNI-06", h: 19, lb: 317465 },
	{ n: "Pass UNI-07", h: 24, lb: 317788 },
	{ n: "Pass UNI-08", h: 31, lb: 318340 },
	{ n: "Pass UNI-09", h: 15, lb: 381919 },
	{ n: "Phaet", h: 16, lb: 124297 },
	{ n: "Phao", h: 20, lb: 98476 },
	{ n: "Phekda", h: 17, lb: 37142 },
	{ n: "Phiagre", h: 13, lb: 45253 },
	{ n: "Phiandgre", h: 20, lb: 322502 },
	{ n: "Phicanho", h: 25, lb: 10913 },
	{ n: "PI 4-669", h: 10, lb: 29230 },
	{ n: "PJ 3373", h: 6, lb: 4117 },
	{ n: "PO 4-991", h: 14, lb: 11238 },
	{ n: "Polaris", h: 14, lb: 83627 },
	{ n: "Pollux", h: 10, lb: 29320 },
	{ n: "PP 5-713", h: 13, lb: 325051 },
	{ n: "Procyon", h: 31, lb: 161635 },
	{ n: "Propus", h: 20, lb: 379815 },
	{ n: "Quaack", h: 25, lb: 162782 },
	{ n: "Quana", h: 26, lb: 11518 },
	{ n: "Quaphi", h: 14, lb: 304816 },
	{ n: "Quator", h: 18, lb: 29520 },
	{ n: "Quexce", h: 24, lb: 106613 },
	{ n: "Quexho", h: 14, lb: 322982 },
	{ n: "Quince", h: 16, lb: 56607 },
	{ n: "Qumia", h: 15, lb: 83767 },
	{ n: "Qumiin", h: 20, lb: 309615 },
	{ n: "Quurze", h: 20, lb: 4177 },
	{ n: "QW 2-014", h: 9, lb: 21257 },
	{ n: "RA 3-124", h: 12, lb: 309975 },
	{ n: "Ras Elased", h: 40, lb: 163482 },
	{ n: "Rashkan", h: 29, lb: 37278 },
	{ n: "Regulus", h: 16, lb: 29844 },
	{ n: "Remo", h: 26, lb: 45526 },
	{ n: "Retho", h: 22, lb: 21392 },
	{ n: "Rigel", h: 34, lb: 165122 },
	{ n: "Ross", h: 15, lb: 46254 },
	{ n: "Rotanev", h: 19, lb: 98896 },
	{ n: "RV 2-578", h: 12, lb: 11934 },
	{ n: "RX 3-129", h: 12, lb: 305054 },
	{ n: "SA 2779", h: 5, lb: 4497 },
	{ n: "Sargas", h: 25, lb: 166788 },
	{ n: "SD 3-562", h: 19, lb: 46509 },
	{ n: "Seginus", h: 18, lb: 99200 },
	{ n: "SF 5-674", h: 22, lb: 310119 },
	{ n: "Siberion", h: 15, lb: 4577 },
	{ n: "Sigma Draconis", h: 20, lb: 12102 },
	{ n: "Silaad", h: 20, lb: 380135 },
	{ n: "Sirius", h: 25, lb: 124569 },
	{ n: "Ska", h: 25, lb: 12602 },
	{ n: "Sobein", h: 12, lb: 331012 },
	{ n: "Sodaack", h: 16, lb: 56831 },
	{ n: "Soessze", h: 20, lb: 21876 },
	{ n: "Sohoa", h: 16, lb: 38003 },
	{ n: "Sol", h: 29, lb: 4952 },
	{ n: "Solaqu", h: 25, lb: 84067 },
	{ n: "Soolti", h: 20, lb: 310405 },
	{ n: "Sophilia", h: 17, lb: 107069 },
	{ n: "Sowace", h: 21, lb: 325246 },
	{ n: "Spica", h: 23, lb: 107477 },
	{ n: "Stein", h: 16, lb: 323220 },
	{ n: "Subra", h: 20, lb: 125319 },
	{ n: "SZ 4-419", h: 7, lb: 30100 },
	{ n: "Tau Ceti", h: 15, lb: 5648 },
	{ n: "TG 2-143", h: 12, lb: 22276 },
	{ n: "Thabit", h: 25, lb: 99506 },
	{ n: "Tiacan", h: 18, lb: 38227 },
	{ n: "Tiacken", h: 28, lb: 22408 },
	{ n: "Tiafa", h: 27, lb: 310825 },
	{ n: "Tianbe", h: 15, lb: 30184 },
	{ n: "Tiexen", h: 20, lb: 13602 },
	{ n: "Tigrecan", h: 13, lb: 331192 },
	{ n: "Tiliala", h: 17, lb: 57071 },
	{ n: "Tiurio", h: 14, lb: 305210 },
	{ n: "Tivea", h: 20, lb: 323476 },
	{ n: "Turais", h: 23, lb: 125719 },
	{ n: "UF 3-555", h: 14, lb: 311473 },
	{ n: "UG 5-093", h: 23, lb: 126179 },
	{ n: "Urandack", h: 15, lb: 13982 },
	{ n: "Ureneth", h: 17, lb: 311669 },
	{ n: "Uressce", h: 17, lb: 331439 },
	{ n: "Urfaa", h: 20, lb: 107937 },
	{ n: "Urhoho", h: 18, lb: 22940 },
	{ n: "Urioed", h: 9, lb: 57496 },
	{ n: "Urlafa", h: 16, lb: 30469 },
	{ n: "Ururur", h: 17, lb: 46946 },
	{ n: "Usube", h: 30, lb: 23264 },
	{ n: "Uv Seti", h: 15, lb: 331779 },
	{ n: "UZ 8-466", h: 13, lb: 84692 },
	{ n: "Veareth", h: 25, lb: 57685 },
	{ n: "Vecelia", h: 26, lb: 380635 },
	{ n: "Veedfa", h: 15, lb: 323976 },
	{ n: "Vega", h: 25, lb: 108857 },
	{ n: "Veliace", h: 16, lb: 332109 },
	{ n: "Vewaa", h: 15, lb: 30741 },
	{ n: "VH 3-344", h: 16, lb: 14282 },
	{ n: "VM 3-326", h: 10, lb: 311975 },
	{ n: "Waarze", h: 14, lb: 58160 },
	{ n: "Waayan", h: 16, lb: 38497 },
	{ n: "Wainze", h: 16, lb: 109607 },
	{ n: "Waiophi", h: 15, lb: 14410 },
	{ n: "Wamien", h: 15, lb: 312225 },
	{ n: "Waolex", h: 25, lb: 84952 },
	{ n: "Wasat", h: 19, lb: 100131 },
	{ n: "Watibe", h: 15, lb: 305560 },
	{ n: "Wezen", h: 20, lb: 126685 },
	{ n: "WG 3-288", h: 13, lb: 31071 },
	{ n: "WI 4-329", h: 21, lb: 332509 },
	{ n: "WO 3-290", h: 11, lb: 47286 },
	{ n: "Wolf", h: 20, lb: 31188 },
	{ n: "WP 3155", h: 7, lb: 6023 },
	{ n: "WW 2-934", h: 11, lb: 127085 },
	{ n: "XC 3-261", h: 13, lb: 14665 },
	{ n: "Xeho", h: 17, lb: 381025 },
	{ n: "Xewao", h: 16, lb: 312600 },
	{ n: "XH 3819", h: 12, lb: 6142 },
	{ n: "YC 3-268", h: 15, lb: 38897 },
	{ n: "Yildun", h: 17, lb: 100606 },
	{ n: "YS 3-386", h: 20, lb: 305875 },
	{ n: "YV 3-386", h: 18, lb: 109879 },
	{ n: "Zamith", h: 18, lb: 23684 },
	{ n: "Zaniah", h: 16, lb: 100844 },
	{ n: "Zaurak", h: 27, lb: 110095 },
	{ n: "Zeaay", h: 14, lb: 332845 },
	{ n: "Zeaex", h: 14, lb: 39107 },
	{ n: "Zearla", h: 16, lb: 306155 },
	{ n: "Zelada", h: 20, lb: 85577 },
	{ n: "Zeolen", h: 12, lb: 14873 },
	{ n: "Zezela", h: 10, lb: 31548 },
	{ n: "Zirr", h: 18, lb: 24008 },
	{ n: "ZP 2-989", h: 14, lb: 58440 },
	{ n: "ZS 3-798", h: 20, lb: 306427 },
	{ n: "ZU 3-239", h: 22, lb: 381297 },
	{ n: "Zuben Elakrab", h: 17, lb: 101100 },
	{ n: "ZZ 2986", h: 5, lb: 6334}
];

var NAME_IDS; // lazily initialized in Sectors.getId

var Sector = {};

Sector.getId = function( sectorName ) {
	if ( NAME_IDS === undefined ) {
		NAME_IDS = CATALOGUE.reduce(
			function( name_ids, data, id ) {
				name_ids[ data.n ] = id;
				return name_ids;
			},
			{}
		);
	}

	return NAME_IDS[ sectorName ];
}

Sector.getName = function( sectorId ) {
	var s = CATALOGUE[ sectorId ];
	return s !== undefined ? s.n : undefined;
}

Sector.getLocation = function( sectorId, x, y ) {
	var s = CATALOGUE[ sectorId ];
	return s !== undefined ? (s.lb + s.h * x + y) : undefined;
}

Sector.getCoords = function( sectorId, location ) {
	var s = CATALOGUE[ sectorId ];
	if ( s === undefined )
		return undefined;
	location -= s.lb;
	return {
		x: Math.floor( location / s.h ),
		y: location % s.h
	};
}

Sector.getIdFromLocation = function( location ) {
	//Returns the sectorId from the location.
	var min = Infinity, sectorId
	CATALOGUE.forEach( findSector )
	
	function findSector( sector, ind ) {
		if ( location - sector[ 'lb' ] < min && location - sector[ 'lb' ] >= 0 ) {
			min = location - sector[ 'lb' ];
			sectorId = ind;
		}
	}
	return sectorId;
}

return Sector;

})();

