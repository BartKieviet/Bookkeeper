// The background code.  This contains app initialisation stuff, including
// migration of storage formats when necessary, and also handles requests sent
// by some content scripts.

var Sector; // from sector.js
var Building; // from building.js

chrome.runtime.onInstalled.addListener( onInstall );
chrome.runtime.onMessage.addListener( onMessage );

// End of script execution, function definitions below.

function onInstall( details ) {
	var v, maj, min, patch;
	if ( details.reason == 'update' ) {
		parseVersion( details.previousVersion );

		if ( maj < 1
		  || (maj === 1 && min < 8)
		  || (maj === 1 && min === 8 && patch < 1) ) {
			// 1.8.1 is the version when we switched from
			// storage.local to storage.sync and 1.9 format.
			//
			// Too bad, mate, your data is too old, we're going to
			// nuke it, sorry :(
			chrome.storage.sync.clear();
		}
		else if ( maj === 1
		       || (maj === 2 && min === 0) ) {
			// 2.1 is the version when we switched to 2.1 format.
			migrateV19Storage();
		}
	}

	function parseVersion( v ) {
		v = v.split( '.' ).map( function(n) { return parseInt(n); });
		while ( v.length < 3 )
			v.push( 0 );
		maj = v[0];
		min = v[1];
		patch = v[2];
	}
}

// Start a migration from storage V1.9 to V2.1.
//
// V1.9 storage format:
//
// The list item keys are `A`, `O`, `P`.
//
// Building keys are `XNNN` where X is `A`, `O`, or `P`, and NNN is the ID
// (e.g. `P142040`).  Each item contains a 14-element array representing:
//
//   0 - time (number, Unix timestamp in seconds)
//   1 - sector_id (number, as per Sector.getId)
//   2 - x (number)
//   3 - y (number)
//   4 - type_id (number, as per Building.getTypeId)
//   5 - level (number, may be -1 if unavailable)
//   6 - owner (string)
//   7-13 - Seven comm dicts for amount, amount_max, amount_min,
//          res_production, res_upkeep, buy_price, sell_price.
//          In that order.
//
// Commodity dictionaries are stored as arrays of numbers: the first being a
// commodity ID; the second, the value for that commodity, and so on.

// V2.1 storage format:
//
// List item keys, and building keys, remain the same as in 1.9.
//
// Building item values are 3 to 10-element arrays, as generated by
// Building.toStorage() (which we use here, because we can).

function migrateV19Storage() {
	var items;

	console.log( "Starting 1.9 migration" );

	chrome.storage.sync.get( null, onData );

	function onData( old ) {
		var key, m, u, loc, a, b;

		// We'll ignore the stored lists and rebuild them, just because
		// it feels like a good time to tidy up, in case these were out
		// of whack for some reason (mine contain some -1's from failed
		// experiments while developing).
		items = { A: [], O: [], P: [] };

		for ( key in old ) {
			m = /^(A|O|P)(\d+)$/.exec( key );
			if ( !m )
				continue;
			u = m[ 1 ];
			loc = parseInt( m[2] );
			a = old[ key ];
			b = migrateV19Building( loc, a );
			if ( b ) {
				items[ u ].push( loc );
				items[ b.storageKey(u) ] = b.toStorage();
			}
		}

		//console.log( 'migration', items );

		// Nuke the old data -- feel the willies here
		chrome.storage.sync.clear( onOldBusted );
	}

	function onOldBusted() {
		// Store the new shiny.
		chrome.storage.sync.set( items, onV21Stored );
	}

	function onV21Stored() {
		if ( chrome.runtime.lastError ) {
			// Balls. What else to do?  We won't delete local
			// storage, hopefully another update will migrate it.
			console.log(
				'Bookkeeper ERROR migrating V1.9 storage: ' +
					chrome.runtime.lastError.message );
		}
		else
			console.log( 'Migrated to V2.1!' );
	}

	function migrateV19Building( loc, a ) {
		var level, ticksLeft,
		    res_upkeep, res_production, amount_min, amount_max, amount,
		    forSale, toBuy, id;

		level = parseInt( a[5] );
		if ( isNaN(level) || level < 1 )
			level = undefined;

		amount = parseCommodityMap( a[7] )
		amount_max = parseCommodityMap( a[8] );
		amount_min = parseCommodityMap( a[9] );
		res_production = parseCommodityMap( a[10] );
		res_upkeep = parseCommodityMap( a[11] );

		// If we have amount, amount_max, amount_min, res_production,
		// res_upkeep, then we build forSale and toBuy.  Otherwise, we
		// store the building without amounts.
		if ( amount && amount_max && amount_min &&
		     res_production && res_upkeep ) {

			forSale = [];
			toBuy = [];

			//console.log( 'loc', loc, 'res_prod', res_production, 'amt', amount, 'min', amount_min );
			// for each commodity in res_production, compute forSale
			// as amount - minimum
			for ( id in res_production ) {
				if ( amount[id] !== undefined && amount_min[id] !== undefined )
					forSale.push( id, amount[id] - amount_min[id] );
			}

			// for each commodity in res_upkeep, compute toBuy
			// as maximum - amount
			for ( id in res_upkeep ) {
				if ( amount[id] !== undefined && amount_max[id] !== undefined )
					toBuy.push( id, amount_max[id] - amount[id] );
			}

			if ( forSale.length === 0 )
				forSale = undefined;
			if ( toBuy.length === 0 )
				toBuy = undefined;
		}

		// Compute ticksLeft like 1.9 did
		if ( level && res_upkeep && amount )
			ticksLeft = numberOfTicks( level, res_upkeep, amount );

		// Mins are maxes are only needed for own buildings, and we
		// weren't computing those correctly anyway, so don't store
		// them.

		return new Building(
			loc,
			a[1], // sectorId
			a[4], // typeId
			a[0], // time
			a[6], // owner
			level,
			ticksLeft,
			forSale,
			toBuy
		);
	}

	function parseCommodityMap( a ) {
		var r, i, end;

		if ( a.length === 0 )
			return undefined;

		for ( r = {}, i = 0, end = a.length; i < end; i += 2 )
			r[ a[i] ] = parseInt( a[i + 1] );

		return r;

	}

	// lifted from building.js V1.9
	function numberOfTicks( level, res_upkeep, amount ) {
		var lowest, key, base, tickAmount, ticks;

		if ( !(level > 0) )
			return undefined;

		lowest = Infinity;
		for ( key in res_upkeep ) {
			base = res_upkeep[ key ];
			tickAmount =
				Math.round( base * ( 1 + 0.4 * (level - 1) ) );
			ticks = Math.floor( amount[key] / tickAmount );
			if ( ticks < lowest )
				lowest = ticks;
		}

		if ( lowest < Infinity )
			return lowest;

		return undefined;
	}
} // function function migrateV19Storage()


// The function below is called when a content script asks the background page
// to do some work for it.
//
// The idea is: when a content script needs something, it builds an object with
// a property `op`, which contains a string naming one of the "op handlers"
// defined further down.  Other properties are added to that object, as required
// by the particular handler.  The object is then sent as a message with
// `chrome.runtime.sendMessage`, and is received by the handler below, who
// dispatches it to the appropriate handler.
//
// Some handlers do not respond anything to the content script.  These can take
// a single parameter, the message, and should always return false.
//
// Some handlers may need to deliver data back to the content script, and this
// data may not be immediately available.  These should accept three parameters;
// the third will be a callback function; they should return true immediately
// and arrange for the callback to be called when the response can be delivered.
//
// If a handler returns true, MAKE SURE THE CALLBACK IS CALLED EVENTUALLY,
// otherwise the content script may just sit there waiting for a response that
// will never arrive.  And Chrome will leak a connection to the background page
// indefinitely, keeping it from unloading when the extension is idle.  We want
// none of this.

function onMessage( message, sender, sendResponse ) {
	var handler = OpHandlers[ message.op ];
	if ( handler )
		return handler( message, sendResponse );
	return false;
}

// Op handlers below.

var OpHandlers = {};

OpHandlers.showNotification = function( message ) {
	var options;

	options = {
		type: 'basic',
		title: 'Pardus Bookkeeper',
		message: message.text,
		iconUrl: 'icons/48.png'
	};

	chrome.notifications.create( message.id, options );

	return false;
}

OpHandlers.queryTicksLeft = function( message, sendResponse ) {
	var keys;

	keys = message.ids.map( function(id) { return message.ukey + id; } );
	chrome.storage.sync.get( keys, onData );
	return true;

	function onData( data ) {
		var key, building, r, now, ticksNow;

		r = {};
		now = Building.now();
		for ( key in data ) {
			building = Building.createFromStorage( key, data[key] );
			ticksNow = building.ticksNow( now );
			r[ building.loc ] = {
				t: ticksNow,
				f: ticksNow === building.ticksLeft &&
					building.isFullyStocked()
			}
		}

		sendResponse( r );
	}
}
